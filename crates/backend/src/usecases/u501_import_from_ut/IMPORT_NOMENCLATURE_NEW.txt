/// Заменить метод import_nomenclature в executor.rs (строки 434-598)
/// Этот код нужно скопировать вручную

    /// Импорт номенклатуры из УТ - упрощенная версия
    async fn import_nomenclature(
        &self,
        session_id: &str,
        connection: &contracts::domain::a001_connection_1c::aggregate::Connection1CDatabase,
    ) -> Result<()> {
        use a004_nomenclature::u501_import_from_ut::UtNomenclatureListResponse;

        tracing::info!("Importing nomenclature for session: {}", session_id);

        let aggregate_index = "a004_nomenclature";

        // Получаем общее количество элементов
        let total = self
            .odata_client
            .get_collection_count(connection, "Catalog_Номенклатура")
            .await
            .ok()
            .flatten();

        tracing::info!("Total nomenclature items to import: {:?}", total);

        let page_size = 100;
        let mut total_processed = 0;
        let mut total_inserted = 0;
        let mut total_updated = 0;
        let mut skip = 0;

        // Загружаем ВСЕ элементы последовательно блоками по 100
        loop {
            let response: UtNomenclatureListResponse = self
                .odata_client
                .fetch_collection(
                    connection,
                    "Catalog_Номенклатура",
                    Some(page_size),
                    Some(skip),
                )
                .await?;

            if response.value.is_empty() {
                break;
            }

            let batch_size = response.value.len();
            tracing::info!("Processing batch: skip={}, size={}", skip, batch_size);

            // Обрабатываем ВСЕ элементы из пакета (и папки, и элементы)
            for odata_item in response.value {
                let item_type = if odata_item.is_folder { "Папка" } else { "Элемент" };

                self.progress_tracker.set_current_item(
                    session_id,
                    aggregate_index,
                    Some(format!("[{}] {} - {}", item_type, odata_item.code, odata_item.description)),
                );

                match self.process_nomenclature(&odata_item).await {
                    Ok(is_new) => {
                        total_processed += 1;
                        if is_new {
                            total_inserted += 1;
                        } else {
                            total_updated += 1;
                        }
                    }
                    Err(e) => {
                        tracing::error!("Failed to process {} {}: {}", item_type, odata_item.code, e);
                        self.progress_tracker.add_error(
                            session_id,
                            Some(aggregate_index.to_string()),
                            format!("Failed to process {} {}", item_type, odata_item.code),
                            Some(e.to_string()),
                        );
                    }
                }

                // Обновляем прогресс после каждого элемента
                self.progress_tracker.update_aggregate(
                    session_id,
                    aggregate_index,
                    total_processed,
                    total,
                    total_inserted,
                    total_updated,
                );
            }

            skip += page_size;

            // Если получили меньше элементов чем запрашивали - это последний батч
            if batch_size < page_size as usize {
                break;
            }
        }

        // Очистить текущий элемент после завершения
        self.progress_tracker
            .set_current_item(session_id, aggregate_index, None);

        self.progress_tracker
            .complete_aggregate(session_id, aggregate_index);

        tracing::info!(
            "Nomenclature import completed: total_processed={}, inserted={}, updated={}",
            total_processed,
            total_inserted,
            total_updated
        );

        Ok(())
    }
