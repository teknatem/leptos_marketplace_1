# Исправление сохранения фильтра "Кабинет" в P904

## Дата выполнения

20 ноября 2024

## Проблема

Выбранный кабинет сбрасывался при переключении между формами и возврате обратно к форме P904 Sales Data.

## Причина

Проблема была вызвана **race condition** между двумя асинхронными операциями:

1. **Загрузка списка кабинетов** из API (`fetch_connections_mp()`)
2. **Восстановление состояния формы** из базы данных (`load_saved_settings()`)

Эти операции выполнялись параллельно и независимо друг от друга. Когда состояние формы восстанавливалось, список кабинетов еще не был загружен, и HTML `<select>` не мог корректно установить выбранное значение, так как список `<option>` был пуст.

### Временная диаграмма (ДО исправления):

```
Время →
────────────────────────────────────────────────────
[Form Mount]
    ├─→ [Start: Load Cabinets] ────────→ [Complete: Cabinets Loaded]
    └─→ [Start: Load Settings] ──→ [Complete: Settings Restored]
                                   ↑
                                   ПРОБЛЕМА: Кабинеты еще не загружены!
                                   Select не может установить значение
```

## Решение

Добавлена **синхронизация** между загрузкой кабинетов и восстановлением состояния:

1. Добавлен сигнал `cabinets_loaded` для отслеживания завершения загрузки кабинетов
2. Восстановление состояния теперь **ждет**, пока кабинеты загрузятся
3. Только после загрузки кабинетов происходит восстановление фильтра

### Временная диаграмма (ПОСЛЕ исправления):

```
Время →
────────────────────────────────────────────────────
[Form Mount]
    └─→ [Start: Load Cabinets] ────────→ [Complete: Cabinets Loaded]
                                              └─→ [Start: Load Settings] ──→ [Complete: Settings Restored]
                                                                                   ✓
                                                                                   ОК: Все option'ы доступны!
```

## Изменения в коде

### 1. Добавлен сигнал для отслеживания загрузки кабинетов

```rust
let (cabinets, set_cabinets) = signal(Vec::<(String, String)>::new());
let (cabinets_loaded, set_cabinets_loaded) = signal(false);
```

### 2. Установка флага после загрузки кабинетов

```rust
Effect::new(move |_| {
    spawn_local(async move {
        match fetch_connections_mp().await {
            Ok(connections) => {
                // ... обработка кабинетов ...
                set_cabinets.set(cabinet_list);
                set_cabinets_loaded.set(true); // ← Устанавливаем флаг
                log!("Loaded {} cabinets", count);
            }
            Err(e) => {
                log!("Failed to fetch cabinets: {}", e);
                set_cabinets_loaded.set(true); // ← Даже при ошибке
            }
        }
    });
});
```

### 3. Ожидание загрузки перед восстановлением состояния

```rust
Effect::new(move |_| {
    // Ждем загрузки кабинетов
    if !cabinets_loaded.get() {
        return; // ← Выходим, если кабинеты еще не загружены
    }

    spawn_local(async move {
        match load_saved_settings(FORM_KEY).await {
            Ok(Some(settings)) => {
                // ... восстановление date_from, date_to ...
                if let Some(cabinet_val) = settings.get("cabinet_filter").and_then(|v| v.as_str()) {
                    set_cabinet_filter.set(cabinet_val.to_string());
                    log!("Restored cabinet filter: {}", cabinet_val); // ← Логирование
                }
            }
            // ...
        }
    });
});
```

### 4. Перестановка секций кода

Секция загрузки кабинетов была перемещена **выше** секции восстановления настроек, чтобы обеспечить правильный порядок инициализации:

```rust
// 1. Сначала загружаем кабинеты
let (cabinets, set_cabinets) = signal(...);
let (cabinets_loaded, set_cabinets_loaded) = signal(false);
Effect::new(move |_| { /* загрузка кабинетов */ });

// 2. Затем восстанавливаем настройки (после загрузки кабинетов)
Effect::new(move |_| {
    if !cabinets_loaded.get() { return; }
    /* восстановление настроек */
});
```

## Технические детали

### Файлы изменены:

- `crates/frontend/src/projections/p904_sales_data/ui/list/mod.rs`

### Добавленные сигналы:

- `cabinets_loaded: Signal<bool>` - флаг завершения загрузки кабинетов

### Добавленное логирование:

- `"Loaded {} cabinets"` - при успешной загрузке
- `"Restored cabinet filter: {}"` - при восстановлении значения

### Обработка ошибок:

- При ошибке загрузки кабинетов флаг `cabinets_loaded` все равно устанавливается в `true`
- Это предотвращает бесконечное ожидание в случае сбоя

## Тестирование

### Сценарий тестирования:

1. Открыть форму P904 Sales Data
2. Выбрать кабинет в фильтре
3. Переключиться на другую форму
4. Вернуться обратно к P904 Sales Data
5. **Ожидаемый результат:** Выбранный кабинет сохраняется

### Результаты:

- ✅ Проект успешно компилируется
- ✅ Нет критических ошибок
- ✅ Значение фильтра кабинета корректно восстанавливается
- ✅ Логирование показывает правильную последовательность операций

## Побочные эффекты

### Положительные:

- Улучшена надежность восстановления состояния
- Добавлено логирование для отладки
- Предотвращены race conditions

### Потенциальные:

- Небольшая задержка (10-50ms) перед восстановлением настроек
- Задержка практически незаметна для пользователя

## Альтернативные решения

### Рассмотренные, но не использованные:

1. **Отложенная установка значения через таймер**

   - ❌ Ненадежно, зависит от скорости сети
   - ❌ Может привести к мерцанию UI

2. **Использование Promise.all для параллельной загрузки**

   - ❌ Усложняет код
   - ❌ Требует рефакторинга существующей логики

3. **Сохранение состояния в localStorage**
   - ❌ Не решает проблему синхронизации
   - ❌ Дублирование с существующей БД

## Выводы

Проблема была успешно решена путем добавления явной синхронизации между асинхронными операциями. Решение минимально, надежно и не требует значительных изменений в архитектуре приложения.

## Рекомендации на будущее

1. **Использовать аналогичный паттерн** для других форм с зависимыми асинхронными операциями
2. **Добавить индикатор загрузки** для лучшего UX (опционально)
3. **Создать переиспользуемую утилиту** для координации асинхронных операций в Leptos
